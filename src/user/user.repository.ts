import { EntityRepository, Repository } from 'typeorm';
import { UserEntity } from '@/user/user.entity';
import { NotFoundException, ConflictException } from '@nestjs/common';

@EntityRepository(UserEntity)
export class UserRepository extends Repository<UserEntity> {
  /**
   * Finds a user by their username. Throws a NotFoundException() if not found.
   * @param username Username of the required user.
   */
  public async findUserByUsername(username: string): Promise<UserEntity> {
    const user = await this.findOne({ where: { username } });
    if (!user)
      throw new NotFoundException(`User with username ${username} not found`);

    return user;
  }

  /**
   * Finds a user by their email. Throws a NotFoundException() if not found.
   * @param email Email of the required user.
   */
  public async findUserByEmail(email: string): Promise<UserEntity> {
    const user = await this.findOne({ where: { email } });
    if (!user)
      throw new NotFoundException(`User with email ${email} not found`);

    return user;
  }

  /**
   * Finds a user by their user id. Throws a NotFoundException() if not found.
   * @param id Id of the required user.
   */
  public async findUserById(id: number): Promise<UserEntity> {
    const user = await this.findOne(id);
    if (!user)
      throw new NotFoundException(`User with the requested id not found`);

    return user;
  }

  /**
   *
   * @param username Self explanatory.
   * @param salt Salt generated by bcrypt.genSalt(). Must be stored in DB for comparison purposes.
   * @param hashedPassword Password hashed with bcrypt.hash().
   * @param email Self explanatory.
   */
  public async createUser(
    username: string,
    salt: string,
    hashedPassword: string,
    email: string,
  ): Promise<UserEntity> {
    const userWithSameEmail = await this.findOne({
      where: { email },
    });
    if (userWithSameEmail) {
      throw new ConflictException('User with the same email already exists');
    }

    const userWithSameUsername = await this.findOne({
      where: { username },
    });
    if (userWithSameUsername) {
      throw new ConflictException('User with same username already exists');
    }

    const newUser = {
      username,
      password: hashedPassword,
      email,
      salt,
    };

    return this.save(newUser);
  }
}
